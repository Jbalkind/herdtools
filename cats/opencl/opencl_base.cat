"OpenCL"
withoutsc

let mo = co & ((!nonatomicloc)^2)
let sb = po
let rb = (rf^-1; mo) \ id

		     
	   
(* Access modes *)
let mo_acq = memory_order_acquire 
let mo_rel = memory_order_release
let mo_acq_rel = memory_order_acq_rel 
let mo_rlx = memory_order_relaxed 
let mo_sc = memory_order_seq_cst

(* Scope annotations *)
let s_wi = memory_scope_work_item 
let s_wg = memory_scope_work_group
let s_dev = memory_scope_device 
let s_all = memory_scope_all_svm_devices

(*******************)
(* Synchronisation *)
(*******************)
	      
let acq = (mo_acq | mo_acq_rel | mo_sc) & (R | F)
let rel = (mo_rel | mo_acq_rel | mo_sc) & (W | F)

(* Fences sequenced before or after *)
let Fsb = [F]; sb
let sbF = sb; [F]
					    
(* Release sequence *)
let rs' = wi | (unv; [R & W])
let rs = mo & rs' & ~((mo & ~rs') ; mo)

(* Inclusive scopes *)
let incl = wg & s_wg^2 | dev & s_dev^2 | s_all^2

(* Inclusive scopes, less conservative 
   (unused) version *)
let incl1 = ([s_wg];wg) | ([s_dev];dev)
	    | ([s_all];unv)
let incl' = incl1 & incl1^-1
			     			    
(* Release-acquire synchronisation *)
let ra_sw(r) =
  ([r & rel]; Fsb?; [W \ s_wi]; rs?; [r]; rf;
   [R \ s_wi]; sbF?; [acq & r]) & incl & ~wi

(* Barrier synchronisation *)
let bar_sw(r) = (entry_fence * exit_fence) &
		  same_B & ~wi & wg & r^2

(* Allowed to synchronise on the other region *)
let scf = mo_sc^2 | (G & L & F)^2

(* Global and local synchronises-with *)
let gsw = ra_sw(G) | bar_sw(G) | (scf & ra_sw(L))  
let lsw = ra_sw(L) | bar_sw(L) | (scf & ra_sw(G)) 

(******************)
(* Happens-before *)
(******************)

(* Global and local happens-before *)
let ghb = (((G^2) & (sb | (I * !I))) | gsw)+ 
let lhb = (((L^2) & (sb | (I * !I))) | lsw)+ 
show ghb
show lhb
irreflexive ghb as O-HbG
irreflexive lhb as O-HbL

(*************)
(* Coherence *)
(*************)

let coh(hb) = (rf^-1)?; mo; rf?; hb
irreflexive coh(ghb) as O-CohG
irreflexive coh(lhb) as O-CohL

(************************)
(* Consistency of reads *)
(************************)

(* A load can only read from a store that already 
   happened. *)
irreflexive rf; (ghb | lhb) as O-Rf
				
(* Visible side effects *)
let vis(hb) = (W * R) & hb & loc &
	       ~((hb & loc); [W]; hb)

(* A non-atomic load can only read from a store 
   that is visible. *)
empty (rf;[G & nonatomicloc])\vis(ghb) as O-NaRfG
empty (rf;[L & nonatomicloc])\vis(lhb) as O-NaRfL

(* Consistency of RMWs *)
irreflexive rf | (mo;mo;rf^-1) | (mo;rf) as O-Rmw

