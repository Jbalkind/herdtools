"GPU_PTX"

{
  \paragraph{SC-per-location with load-load hazard} 
  We require that communications do not
  contradict program order, unless the events
  are for different locations, or both events
  are reads.
}

let com = rf | fr | co
let po-loc-llh = 
  WW(po-loc) | WR(po-loc) | RW(po-loc)
acyclic (po-loc-llh | com) as sc-per-loc-llh

{
  \paragraph{No thin air} 
  This prevents causal loops. No event
  may read from its dependants.
}

let dp = addr | data | ctrl
acyclic (dp | rf) as no-thin-air

{
  \paragraph{Scoped RMO} 
  We now integrate the concurrency hierarchy.
  The $X${\tt -fence} relation relates events
  that are separated by a fence of scope $X$
  or wider.
}

let sys-fence = membar.sys
let gl-fence  = membar.gl  | sys-fence
let cta-fence = membar.cta | gl-fence

{ 
  We declare a generic {\tt rmo} relation, and
  instantiate it for each scope. We implement
  RMO-per-scope by requiring each of these
  relations to be acyclic.
}

let rmo(fence) = dp | fence | rfe | co | fr
let rmo-cta = rmo(cta-fence) & int-cta
let rmo-gl = rmo(gl-fence) & int-dev
let rmo-sys = rmo(sys-fence) & unv

acyclic rmo-cta as cta-constraint
acyclic rmo-gl as gl-constraint
acyclic rmo-sys as sys-constraint
