This file describes the preliminary C++11 model in Herd.

The model can be found in cpp11.cat, (best viewed in ocaml mode)

The model is currently limited to loads and stores with memory orders:
non-atomic
relaxed
release
acquire

For a description of Herd, see the paper at:
http://diy.inria.fr/herd/

-----------------------------------------------------------------
NEW FEATURES

I've added some features in order to implement some of the constraints
required by C++11. These features are:

Relation Complement : Noted by the ~ character, takes the complement 
                      of the relation

Relation Inverse : Noted by the ' character, takes the inverse of the 
                   relation

Filter Operation : Used like MM, WM, WR etc, this filters either the 
                   domain or the range based on attributes defined
                   by the architecture. For example, in C++11 we may
		   to consider a relation where at least one operation
		   is non atomic. 
		   We do that by filtering non-atomics (an attribute
		   defined in the CPP11 architecture file) from the
		   universal relation. i.e.

		   let one_non_atomic = F[non_atomic]F[](unv) |
                                        F[]F[non_atomic](unv)

		   The syntax (as you can tell from the example)
		   is F[attribute]F[attribute](relation). An
		   empty attribute list returns true for all events.

		   The CPP11 architecture supports and memory order
		   as an attribute. 

-----------------------------------------------------------------
Examples

Some examples (mostly based around the MP litmus test) can be found
in CPP11Tests/

to run the examples do:

./herd -model cpp11.cat example.litmus

to produce a .dot output, add the flags:

-o <directory to place .dot file> -show prop -web

In examples with data races, you may change the line in cpp11.cat from
"empty dr"
to
"show dr"

then examples with data races are allowed, and the racing events
are shown in the .dot output.

Here are the examples described:

MP_relaxed.litmus - Performs MP with relaxed atomics, all outcomes
                    are observable

MP_dr.litmus - Same as MP_relaxed.litmus with first store and last load
               changed to non-atomics so that they race. No executions
	       are allowed because they all contain a data race.

MP_relacq.litmus - Same as MP_dr.litmus with atomics turned to release acquire. 
		 The only execution that doesn't contain a data-race is 
		 when both loads return 1.

MP_relseq.litmus - Same as MP_relacq.litmus but with a release sequence. 
                   In this example, the dot output shows the appropriate 
		   sw edge even when the load reads from a store in the release
		   sequence.

