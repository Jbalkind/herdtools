"OpenCL"

let set cacq = acq | sc
let set crel = rel | sc

let dd = data | addr

let pp_asw = asw \ (asw;po)
let pol = po & loc
let com = rf | fr | co

let set gtewi  = wi | wg | dev | all_dev
let set gtewg  = wg | dev | all_dev
let set gtedev = dev | all_dev
let dwi_scope  = [gtewi * gtewi]
let dwg_scope  = [gtewg * gtewg]
let ddev_scope = [gtedev * gtedev]
let dall_scope = [all_dev * all_dev]
let inclusive_scopes = int (dwi_scope)     | (int-wg & dwg_scope) |
                       (int-dev & ddev_scope) | dall_scope

let gidf = (po; [gF])?
let gfid = ([gF]; po)?
let grs = [crel]; gfid; [A & W & global_loc]; (((co ; [rmw]) | coi) & ~(coe ; [~rmw] ; co))?
let gswra = inclusive_scopes & ext (grs; rf; [A]; gidf; [cacq])
let gsw = pp_asw | gswra
let ghb = (po | gsw)+
let ghbl = ghb & loc
let gvse = [W];ghbl;[R] & ~(ghbl; [W]; ghbl)
provides acyclic ghb as ghbAcyclic
provides acyclic (ghbl | com) as ghbuniproc

let lidf = (po; [lF])?
let lfid = ([lF]; po)?
let lrs = [crel]; lfid; [A & W & local_loc]; (((co ; [rmw]) | coi) & ~(coe ; [~rmw] ; co))?
let lswra = inclusive_scopes & ext (lrs; rf; [A]; lidf; [cacq])
let lsw = pp_asw | lswra
let lhb = (po | lsw)+
let lhbl = lhb & loc
let lvse = [W];lhbl;[R] & ~(lhbl; [W]; lhbl)
provides acyclic lhb as lhbAcyclic
provides acyclic (lhbl | com) as lhbuniproc

let narf = rf; [na]
let narfvse = narf;~((gvse | lvse)^-1)
provides irreflexive narfvse as nonAtomicRfConsistent

let arf = rf; [A]
let hbarf = (ghb | lhb);arf
provides irreflexive hbarf as atomicRfConsistent

(* There's no restriction to local or global here. Is that right? *)
let idf = (po; [F])?
let fid = ([F]; po)?
let scco = [sc]; fid; co; idf; [sc]
let scfr = ~[_] &
           ( ([sc]    ; rf^-1; (ghbl | lhbl)  ; [W & sc]) |
             ([sc]    ; rf^-1; [sc] ; co; [sc]) |
             ([sc & F]; po; fr;     [sc]    ) |
             (    [sc];     fr; po; [sc & F]) |
             ([sc & F]; po; fr; po; [sc & F])
           )
let scghb = [sc]; ghb; [sc]
let sclhb = [sc]; lhb; [sc]
let sc = scghb | sclhb | scco | scfr
provides acyclic sc as scConsistent
show sc

let glhb = ghb | lhb
let dr = ext ([W * _] | [_ * W]) &
         loc & 
         (~[A * A]) &
         ~glhb & ~(glhb^-1) &
         ~inclusive_scopes

let ur = int ([W * M] | [M * W]) &
         loc &
         ~[_] &
         ~po & ~(po^-1)

show dr
show ur
requires empty dr as dataRace 
requires empty ur as unsequencedRace 

