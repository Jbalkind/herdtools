"OpenCL"

{%(*
\paragraph{Preliminaries} Some abbreviations.
%*)}

let mo_acq = memory_order_acquire
let mo_rel = memory_order_release
let mo_acq_rel = memory_order_acq_rel
let mo_sc = memory_order_seq_cst

let s_wi = memory_scope_work_item
let s_wg = memory_scope_work_group
let s_dev = memory_scope_device
let s_all = memory_scope_all_svm_devices

{%(*
We define a shorthand for the symmetric closure of a relation.
%*)}

let symm(r) = r | r^-1

{%(*
Let \var{acq} and \var{rel} be the sets of events with `acquire' and `release' semantics, respectively. These include events from instructions explicitly annotated with \code{memory_order_acquire} or \code{memory_order_release}, and also from those annotated with \code{memory_order_acq_rel} (since ``[a] synchronization operation with acquire-release semantics has the properties of both the acquire and release memory orders''). Moreover, an SC load/fence has `acquire' semantics, and an SC store/fence has `release' semantics (``a sequentially-consistent fence [has] both acquire and release semantics''). \fixme{John: Find citation to confirm that SC loads/stores should have acquire/release semantics.}
%*)}

let acq = mo_acq | (mo_sc & (R | F)) | mo_acq_rel
let rel = mo_rel | (mo_sc & (W | F)) | mo_acq_rel

{%(*
The primitive \var{asw} (additional synchronizes-with) relation relates every initialisation event to every non-initialisation event. We define \var{asw'} as a simpler version that relates initialisation events only to those non-initialisation events that come first in program-order. Then we define \var{po_asw} as the transitive closure of program-order augmented with \var{asw'}.
%*)}

let asw' = asw \ (asw;po)
let po_asw = (po | asw')+

{%(* 
The primitives \var{gF} and \var{lF} represent the global and local fences respectively. Let \var{glF} represents fences that are \emph{both} global and local.
%*)}

let glF = gF & lF

{%(*
\paragraph{Scope inclusion}
The relation \var{incl} contains those pairs of events that have \emph{inclusive scopes}: their expected separation is no greater than their actual separation.
%*)}

let incl_wi(s) = int(s^2)
let incl_wg(s) = wg & (s^2)
let incl_dev(s) = dev & (s^2)
let incl_all(s) = s^2

let incl = 
  incl_wi(s_wi) | incl_wg(s_wg) | incl_dev(s_dev) | incl_all(s_all) 

{%(*
The following is a more liberal (but unused) version of scope inclusion, which defines the expected separation as the \emph{minimum} of the two annotations.
%*)}

let s_dev' = s_all | s_dev
let s_wg' = s_all | s_dev | s_wg
let s_wi' = s_all | s_dev | s_wg | s_wi

let incl' = 
  incl_wi(s_wi') | 
  incl_wg(s_wg') |
  incl_dev(s_dev') | 
  incl_all(s_all)

{%(* 
\paragraph{Release sequence}
``A \emph{release sequence} begins with a release operation $A$ on an atomic object $M$ and is the maximal contiguous sub-sequence of side effects in the modification order of $M$, where the first operation is $A$ and every subsequent operation either is performed by the same work-item or host thread that performed the release or is an atomic read-modify-write operation.''

We define $\var{rel_seq}(f)$ as the set of pairs $(a,b)$ for which $b$ is in the release sequence headed by the event $a$. 

As a first step, we define $\var{co_rmw_or_same_wi}$ as the set of pairs $(a,b)$ for which $b$ either is performed by the same work-item or host thread that performed $a$ or is an atomic read-modify-write operation.
%*)}

let co_rmw_or_same_wi = (co ; [rmw]) | coi

{%(* 
As a second step, we refine this set by ruling out pairs $(a,b)$ for which there is a chain in the modification order that goes from $a$ to $b$ and passes through an intermediate event that is not an atomic read-modify-write and is not in the same work-item as $a$. \fixme{John: I haven't managed to understand this yet.}
%*)}

let max_co_rmw_or_same_wi = co_rmw_or_same_wi & ~(coe ; [!rmw] ; co)

{%(* 
We must be careful when defining the beginning of a release sequence. The specification talks of ``a release operation [...] on an atomic object'', which neglects to consider the possibility that the release operation is a fence, and hence has no object. We therefore distinguish two cases. If $a$ is a release write to a global location $x$, then its release sequence contains events in $x$'s modification order. If $a$ is a release fence, then its release sequence contains events in the modification order of any global location that is written atomically after the fence in program order. \fixme{John: Why do we use \var{global\_loc} here? What about local locations?}
%*)}

let rel'(F) = [rel]; ([F]; po)?; [A & W & global_loc]

{%(* 
We take this opportunity to present the symmetric case for acquire operations. If $a$ is an acquire read from a global location $x$, then it shall read from $x$'s release sequence. But if $a$ is an acquire fence, then it shall read from the release sequence of any global location that is accessed atomically before the fence in program order.
%*)}

let acq'(F) = [A]; (po; [F])?; [acq]

{%(* 
Note that \var{co} is transitive but not reflexive, so we use the \code{?}-operator to ensure that $a$'s release sequence contains itself.
%*)}

let rel_seq(F) = rel'(F); max_co_rmw_or_same_wi?

{%(* 
\paragraph{Synchronisation}
We define $\var{ir_sw}(f)$ (intra-region synchronizes-with) as the set of pairs of events $(a,b)$ that synchronise with each other on the same region. The events must have inclusive scopes, they must be in different work-items, and $b$ must acquire from $a$'s release sequence.
%*)}

let ir_sw(F) = incl & ext (rel_seq(F); rf; acq'(F))

{%(* 
We define $\var{g_sw}(f,f')$ (global synchronizes-with) as the set of pairs of events that either synchronise via global fences, or synchronise via local fences and either are both SC operations or are both global/local fences. \fixme{John: That last bit doesn't make much sense to me, and I suspect it might be wrong.}
%*)}

let sw(F,F') = ir_sw(F) | ((mo_sc^2 | glF^2) & ir_sw(F'))
let g_sw = sw(gF,lF)
let l_sw = sw(lF,gF)

{%(*
\paragraph{Happens before}
We now define global and local happens-before, and require each to be acyclic. Global happens-before contains all program-order edges between global locations, plus all global synchronizes-with edges. Local happens-before contains all program-order edges between local locations, plus all local synchronizes-with edges.
%*)}

let g_hb = (((global_loc^2) & po_asw) | g_sw)+
let l_hb = (((local_loc^2) & po_asw) | l_sw)+
let hb = g_hb | l_hb

acyclic g_hb as ghb_acyclic
acyclic l_hb as lhb_acyclic

{%(*
Global and local happens-before, each restricted to events on the same location.
%*)}

let g_hbl = g_hb & loc
let l_hbl = l_hb & loc
let hbl = g_hbl | l_hbl

{%(*
\paragraph{Coherence}
We require that the four types of coherence-violating cycle must not exist. These are read-read, read-write, write-read and write-write. Coherence is required on both the global and the local memory regions.
%*)}
let corr(hbl) = fr; rf; hbl
let corw(hbl) = co; rf; hbl
let cowr(hbl) = fr; hbl
let coww(hbl) = co; hbl

let coherence(r) = corr(r) | cowr(r) | corw(r) | coww(r)

irreflexive coherence(g_hbl) as global_coherence
irreflexive coherence(l_hbl) as local_coherence

{%(*
\paragraph{Visible side effects.}
First, we define a pair of events to have `no intervening write with respect to the relation $r$' if they are related by $r$ but there is no $r$-chain between them that passes through a write event.
%*)}

let no_intervening_write(r) = r & ~(r; [W]; r)

{%(*
We then define $\var{vse}(\var{hbl},\var{region})$ as the set of pairs of events $(a,b)$ where the write $a$ to a location in region \var{region} is visible to the read $b$ of the same location, which means that $b$ happens-after $a$ and there is no intervening write to the same location. There are global and local versions of this relation.
%*)}

let vse(hbl,region) = [W]; no_intervening_write(hbl); [R & region]
let g_vse = vse(g_hbl,global_loc)
let l_vse = vse(l_hbl,local_loc)

{%(*
A non-atomic load can only read from a store that is visible.
%*)}

let g_na_rf = rf; [nonatomicloc & global_loc]; ~(g_vse^-1)
irreflexive g_na_rf as g_nonatomic_rf_consistent

let l_na_rf = rf; [nonatomicloc & local_loc]; ~(l_vse^-1)
irreflexive l_na_rf as l_nonatomic_rf_consistent

{%(*
An atomic load can only read from a store that already happened.
%*)}

let g_a_rf = g_hb; rf; [atomicloc & global_loc]
irreflexive g_a_rf as g_atomic_rf_consistent

let l_a_rf = l_hb; rf; [atomicloc & local_loc]
irreflexive l_a_rf as l_atomic_rf_consistent

{%(*
\paragraph{Read-modify-write atomicity} 
\fixme{John: I'm not sure what this is about yet.}
%*)}

let rmwv = rf;[rmw] | (co;fr) | (co;rf)
irreflexive rmwv as rmw_atomicity

{%(*
\paragraph{Sequential consistency}
We define \var{sc_co} as the per-location modification order (\var{co}) restricted to SC accesses. It contains the pair of events $(a,b)$ only if both are annotated with \code{memory_order_seq_cst}. The event $a$ is either an SC write to $x$ or an SC fence that precedes a write to $x$ in program order. The event $b$ is either a SC write to $x$ or an SC fence that follows a write to $x$ in program order. \fixme{Mark: There should be two models, with this optional. Also, there's no restriction to local or global here. Is that right?}
%*)}

let sc_co = 
  [mo_sc]; ([F]; po)?; co; (po; [F])?; [mo_sc]

{%(*
We define \var{sc_fr} as the from-read relation (\var{fr}) restricted to SC events. \fixme{John: We should say more about this. Also, I added in the disjunct \code{[mo_sc]; fr; [mo_sc]} which wasn't previously allowed. Hopefully that's ok.}
%*)}

let sc_fr1 = [mo_sc]; rf^-1; hbl; [W & mo_sc]
let sc_fr2 = [mo_sc]; rf^-1; [mo_sc]; co; [mo_sc]
let sc_fr3 = noid ([mo_sc]; ([F]; po)?; fr; (po; [F])?; [mo_sc])
let sc_fr = sc_fr1 | sc_fr2 | sc_fr3

{%(*
We define \var{sc_ghb} and \var{sc_lhb} as the global and local happens-before relations restricted to SC events.
%*)}

let sc_ghb = [mo_sc]; g_hb; [mo_sc]
let sc_lhb = [mo_sc]; l_hb; [mo_sc]

{%(*
The various sc relations must not form cycles.
%*)}

let scp = sc_ghb | sc_lhb | sc_co | sc_fr
acyclic scp as sc_consistent

{%(*
\paragraph{Data races}
There is a \emph{data race} between a pair of events if at least one is a write, they access the same location, they are unrelated by happens-before, and their scopes are not inclusive.
%*)}

let either_write = (W * _) | (_ * W)
let dr = either_write & loc & ~symm(hb) & ~incl
show dr
undefined_unless empty dr as data_race 

{%(*
\paragraph{Unsequenced races}
There is an \emph{unsequenced race} between a pair of events if they are different events, they belong to the same thread, at least one is a write, they access the same location, and they are unrelated by program-order.
%*)}

let ur = noid (int (either_write)) & loc & ~symm(po)
show ur
undefined_unless empty ur as unsequenced_race 
