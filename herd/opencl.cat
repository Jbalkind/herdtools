"OpenCL"

(* This model covers the fragment wh*)

let cacq = 
  memory_order_acquire | 
  (memory_order_seq_cst & (R | F)) | 
  memory_order_acq_rel

let crel = 
  memory_order_release | 
  (memory_order_seq_cst & (W | F)) | 
  memory_order_acq_rel

let dd = data | addr

let pp_asw = asw \ (asw;po)
let pol = po & loc
let com = rf | fr | co

let glF = gF & lF

(* nested scope incusion --- unused, for now *)
let gteall = memory_scope_all_svm_devices
let gtedev = memory_scope_device | gteall
let gtewg  = memory_scope_work_group | gtedev
let gtewi  = memory_scope_work_item | gtewg
let inclusive_scopes = 
  int (gtewi^2) | 
 (* (wg & (gtewg^2)) |
  (dev & (gtedev^2)) | *)
  (gteall^2)

(* standard scope inclusion *)
let std_inclusive_scopes =  
  int (memory_scope_work_item^2) |
 (* (wg & (memory_scope_work_group^2)) |
  (dev & (memory_scope_device^2)) | *)
  (memory_scope_all_svm_devices^2)

let idf(f) = (po; [f])?
let fid(f) = ([f]; po)?

let rs(f) = [crel]; fid(f); [A & W & global_loc]; (((co ; [rmw]) | coi) & ~(coe ; [!rmw] ; co))?

(* region-only synchronises with *)
let rosw(f) = std_inclusive_scopes & ext (rs(f); rf; [A]; idf(f); [cacq])

(* region fence, other region fence *)
let sw(rf,orf) = 
  rosw(rf) | 
  ( ( (memory_order_seq_cst^2) | 
    (glF * glF) ) &
  rosw(orf) )

let poasw = (po | pp_asw)+
let gpoasw = [global_loc] ; poasw ; [global_loc]
let lpoasw = [local_loc] ; poasw ; [local_loc]

let ghb = (gpoasw | sw(gF,lF))+
let lhb = (lpoasw | sw(lF,gF))+

acyclic ghb as ghbAcyclic
acyclic lhb as lhbAcyclic

let rloc(r) = r & loc
let ghbl = rloc(ghb)
let lhbl = rloc(lhb)

let vse(hbl,region_loc) = 
  ([W];hbl;[R & region_loc]) & ~(hbl; [W]; hbl)

let gvse = vse(ghbl,global_loc)
let lvse = vse(lhbl,local_loc)

let corr(hbl) = fr;rf;hbl
let corw(hbl) = co;rf;hbl
let cowr(hbl) = fr;hbl
let coww(hbl) = co;hbl

irreflexive ( corr(ghbl) | cowr(ghbl) | corw(ghbl) | coww(ghbl)
            | corr(lhbl) | cowr(lhbl) | corw(lhbl) | coww(lhbl)
            ) as coherence

let gnarf = rf;[nonatomicloc & global_loc]
let gnarfvse = gnarf;~(gvse^-1)
irreflexive gnarfvse as gnonAtomicRfConsistent

let garf = rf;[atomicloc & global_loc]
let ghbarf = ghb;garf
irreflexive ghbarf as gatomicRfConsistent

let lnarf = rf; [nonatomicloc & local_loc]
let lnarfvse = lnarf;~(lvse^-1)
irreflexive lnarfvse as lnonAtomicRfConsistent

let larf = rf; [atomicloc & local_loc]
let lhbarf = lhb;larf
irreflexive lhbarf as latomicRfConsistent


let rmwv = rf;[rmw] | (co;fr) | (co;rf)
irreflexive rmwv as rmwAtomicity


(* There should be two models, with this optional: *)
(* There's no restriction to local or global here. Is that right? *)
let scco = 
  [memory_order_seq_cst]; fid(F); co; idf(F); [memory_order_seq_cst]

let scfr = ~[_] &
  ( 
  ([memory_order_seq_cst]; rf^-1; (ghbl | lhbl); 
   [W & memory_order_seq_cst]) 
  |
  ([memory_order_seq_cst]; rf^-1; 
   [memory_order_seq_cst]; co; [memory_order_seq_cst]) 
  |
  ([memory_order_seq_cst & F]; po; fr; [memory_order_seq_cst]) 
  |
  ([memory_order_seq_cst]; fr; po; [memory_order_seq_cst & F]) 
  |
  ([memory_order_seq_cst & F]; po; fr; po; [memory_order_seq_cst & F])
  )

let scghb = [memory_order_seq_cst]; ghb; [memory_order_seq_cst]
let sclhb = [memory_order_seq_cst]; lhb; [memory_order_seq_cst]
let scp = scghb | sclhb | scco | scfr
(* We deal with the non-sc model initially, so we don't impose the condition: *)
(*provides acyclic scp as scConsistent*)
(*  show sc *)

let glhb = ghb | lhb
let dr = ext ((W * _) | (_ * W)) &
         loc & 
         (~(A^2)) &
         ~glhb & ~(glhb^-1) &
         ~std_inclusive_scopes

let ur = int ((W * M) | (M * W)) &
         loc &
         ~[_] &
         ~po & ~(po^-1)

show dr
show ur
undefined_unless empty dr as dataRace 
undefined_unless empty ur as unsequencedRace 
