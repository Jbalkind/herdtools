"OpenCL"

{%(*
\newcommand\myquote[2]{\begingroup%
\definecolor{shadecolor}{rgb}{0.9,0.9,1}%
\begin{shaded*}\noindent\ignorespaces#2\hfill{\scriptsize\mbox{[OpenCL standard, #1]}}\end{shaded*}\endgroup\noindent\ignorespaces}

\paragraph{Preliminaries} Some abbreviations.
%*)}

let mo_acq = memory_order_acquire
let mo_rel = memory_order_release
let mo_acq_rel = memory_order_acq_rel
let mo_sc = memory_order_seq_cst

let s_wi = memory_scope_work_item
let s_wg = memory_scope_work_group
let s_dev = memory_scope_device
let s_all = memory_scope_all_svm_devices

let total = _ * _
let wi = int(total)
let neq = noid(total)

{%(*
We define a shorthand for the symmetric closure of a relation.
%*)}

let symm(r) = r | r^-1

{%(*
Let \var{acq} and \var{rel} be the sets of events with `acquire' and `release' semantics, respectively. 

\myquote{p.~19}{
Note that the memory orders acquire, sequentialy consistent, and acquire\_release all include acquire semantics
}
\myquote{p.~12}{
Note that the memory orders release, sequentially consistent, and acquire\_release all include release semantics.
}
%*)}

let acq = mo_acq | (mo_sc & (R | F)) | mo_acq_rel
let rel = mo_rel | (mo_sc & (W | F)) | mo_acq_rel

{%(*
The primitive \var{asw} (additional synchronizes-with) relation relates every initialisation event to every non-initialisation event. We define \var{asw'} as a simpler version that relates initialisation events only to those non-initialisation events that come first in program-order. Then we define \var{po_asw} as the transitive closure of program-order augmented with \var{asw'}.
%*)}

let asw' = asw \ (asw;po)
let po_asw = (po | asw')+

{%(* 
The primitives \var{gF} and \var{lF} represent the global and local fences respectively. Let \var{glF} represents fences that are \emph{both} global and local.
%*)}

let glF = gF & lF

{%(*
\paragraph{Scope inclusion}
The relation \var{incl} contains those pairs of events that have \emph{inclusive scopes}: their expected separation is no greater than their actual separation.

\myquote{p.~20}{
Two actions $A$ and $B$ are defined to have an inclusive scope if they have the same scope $P$ such that:
\begin{itemize}
\item $P$ is \code{memory_scope_work_group} and $A$ and $B$ are executed by work-items within the same workgroup.
\item $P$ is \code{memory_scope_device} and $A$ and $B$ are executed by work-items on the same device.
\item $P$ is \code{memory_scope_all_svm_devices} if $A$ and $B$ are executed by host threads or by work-items on one or more devices that can share SVM memory with each other and the host process.
\end{itemize}
}
We include \code{memory_scope_work_item} in our formalisation, because this provides a convenient encoding of nonatomic operations in later definitions.
%*)}

let incl_wi(s) = wi & (s^2)
let incl_wg(s) = wg & (s^2)
let incl_dev(s) = dev & (s^2)
let incl_all(s) = s^2

let incl = 
  incl_wi(s_wi) | incl_wg(s_wg) | incl_dev(s_dev) | incl_all(s_all) 

{%(*
The following is a more liberal (but unused) version of scope inclusion, which defines the expected separation as the \emph{minimum} of the two annotations.
%*)}

let s_dev' = s_all | s_dev
let s_wg' = s_all | s_dev | s_wg
let s_wi' = s_all | s_dev | s_wg | s_wi

let incl' = 
  incl_wi(s_wi') | 
  incl_wg(s_wg') |
  incl_dev(s_dev') | 
  incl_all(s_all)

{%(* 
\paragraph{Release sequence}~

\myquote{p.~45}{
A \emph{release sequence} begins with a release operation $A$ on an atomic object $M$ and is the maximal contiguous sub-sequence of side effects in the modification order of $M$, where the first operation is $A$ and every subsequent operation either is performed by the same work-item or host thread that performed the release or is an atomic read-modify-write operation.
}

We must be careful when defining the beginning of a release sequence. The specification talks of ``a release operation [...] on an atomic object'', but this neglects to consider the possibility that the release operation is a fence, and hence has no object. We therefore distinguish two cases.
\begin{itemize}
\item If the release operation is a release write, then the object is, of course, the object being written. 
\item If the release operation is a fence, the object can be any object that is atomically written to by any instruction that comes \emph{after} the fence in program order. 
\end{itemize}
\fixme{John: Why do we use \var{global\_loc} here? What about local locations?}
%*)}

let rel'(F) = [rel]; ([F]; po)?; [A & W & global_loc]

{%(* 
We take this opportunity to present the symmetric case for acquire operations.
\begin{itemize}
\item If the acquire operation is an acquire read, then the object is, of course, the object being read. 
\item If the acquire operation is a fence, the object can be any object that is atomically read by any instruction that comes \emph{before} the fence in program order. 
\end{itemize}
%*)}

let acq'(F) = [A & R]; (po; [F])?; [acq]

{%(*
We define \var{rmw_or_same_wi} as the set of pairs $(a,b)$ for which $b$ either is performed by the same work-item that performed $a$ or is an atomic RMW operation. 
%*)}
let rmw_or_same_wi = (_ * rmw) | wi

{%(* 
We then define \var{max_co} as the set of pairs $(a,b)$ for which
\begin{itemize}
\item $b$ is after $a$ in the modification order, 
\item $b$ satisfies \var{rmw_or_same_wi} with respect to $a$, 
\item there exists no intermediate event between $a$ and $b$ in the modification order that fails to satisfy \var{rmw_or_same_wi} with respect to $a$.
\end{itemize}
%*)}

let max_co = co & rmw_or_same_wi & ~((co & ~rmw_or_same_wi) ; co)

{%(* 
We define $\var{rel_seq}(F)$ as the set of pairs $(a,b)$ for which $b$ is in the release sequence headed by the event $a$. Note that \var{co} is transitive but not reflexive, so we use the \code{?}-operator to ensure that $a$'s release sequence contains itself.
%*)}

let rel_seq(F) = rel'(F); max_co?

{%(* 
\paragraph{Synchronisation}~
\myquote{p.~47}{
An atomic operation $A$ that performs a release operation on a global object $M$ global-synchronizes-with an atomic operation $B$ that performs an acquire operation on $M$ and reads a value written by any side effect in the release sequence headed by $A$. A similar rule holds for atomic operations on objects in local memory [...]
}
Note that the paragraph above should (we believe) mention that $A$ and $B$ must have inclusive scopes.
\myquote{p.~50}{
A global release fence $A$ global-synchronizes-with a global acquire fence $B$ if there exist atomic operations $X$ and $Y$, both operating on some global atomic object $M$, such that $A$ is sequenced-before $X$, $X$ modifies $M$, $Y$ is sequenced-before $B$, $Y$ reads the value written by $X$ or a value written by any side effect in the hypothetical release sequence $X$ would head if it were a release operation, and that the scopes of $A$, $B$ are inclusive.

A global release fence $A$ global-synchronizes-with an atomic operation $B$ that performs an acquire operation on a global atomic object $M$ if there exists an atomic operation $X$ such that $A$ is sequenced-before $X$, $X$ modifies $M$, $B$ reads the value written by $X$ or a value written by any side effect in the hypothetical release sequence $X$ would head if it were a release operation, and the scopes of $A$ and $B$ are inclusive.

An atomic operation $A$ that is a release operation on a global atomic object $M$ global-synchronizes-with a global acquire fence $B$ if there exists some atomic operation $X$ on $M$ such that $X$ is sequenced-before $B$ and reads the value written by $A$ or a value written by any side effect in the release sequence headed by $A$, and the scopes of $A$ and $B$ are inclusive.

[Analogous paragraphs about local operations omitted.]
}
We define $\var{ir_sw}(F)$ (intra-region synchronizes-with) as the set of pairs of events $(A,B)$ that synchronise with each other on the same region. The events must have inclusive scopes, they must be in different work-items, and $B$ must acquire from $A$'s release sequence. 

%*)}

let ir_sw(F,region) = incl & ~wi & (rel_seq(F); [region]; rf; acq'(F))

{%(* 
We define $\var{g_sw}(F,F')$ (global synchronizes-with) as the set of pairs of events that either synchronise via global fences, or synchronise via local fences and either are both SC operations or are both global/local fences. We define $\var{l_sw}(F,F')$ (local synchronizes-with) as the set of pairs of events that either synchronise via local fences, or synchronise via global fences and either are both SC operations or are both global/local fences. 
\myquote{p.~48}{
Let $X$ and $Y$ be two \code{memory_order_seq_cst} operations. If $X$ local-synchronizes-with or global-synchronizes-with $Y$ then $X$ both local-synchronizes-with $Y$ and global-synchronizes-with $Y$.
}
\myquote{p.~51}{
Let $X$ and $Y$ be two work item fences that each have both the \code{CLK_GLOBAL_MEM_FENCE} and \code{CLK_LOCAL_MEM_FENCE} flags set. If $X$ either local-synchronizes-with or global-synchronizes-with $Y$, then $X$ both local-synchronizes-with $Y$ and global-synchronizes-with $Y$.
}
%*)}

let g_sw = ir_sw(gF, global_loc) | ((mo_sc^2 | glF^2) & ir_sw(lF, local_loc))
let l_sw = ir_sw(lF, local_loc) | ((mo_sc^2 | glF^2) & ir_sw(gF, global_loc))


{%(*
\paragraph{Happens before}
We now define global and local happens-before, and require each to be acyclic. Global happens-before contains all program-order edges between global locations, plus all global synchronizes-with edges. Local happens-before contains all program-order edges between local locations, plus all local synchronizes-with edges.
\myquote{pp.~45--46}{
A global memory action $A$ global-happens-before a global memory action $B$ if 
\begin{itemize}
\item $A$ is sequenced-before $B$, or
\item $A$ global-synchronizes-with $B$, or
For some global memory action $C$, $A$ global-happens-before $C$ and $C$ global-happens-before $B$.
\end{itemize}
A local memory action $A$ local-happens-before a local memory action $B$ if
\begin{itemize}
\item $A$ is sequenced-before $B$, or
\item $A$ local-synchronizes-with $B$, or
\item For some local memory action $C$, $A$ local-happens-before $C$ and $C$ local-happens-before $B$.
\end{itemize}}
%*)}

let g_hb = (((global_loc^2) & po_asw) | g_sw)+
let l_hb = (((local_loc^2) & po_asw) | l_sw)+
let hb = g_hb | l_hb

{%(*
\myquote{p.~46}{
An OpenCL implementation shall ensure that no program execution demonstrates a cycle in either the local-happens-before relation or the global-happens-before relation.
}
%*)}

acyclic g_hb as ghb_acyclic
acyclic l_hb as lhb_acyclic

{%(*
We restrict global and local happens-before to events on the same location.
%*)}

let g_hbl = g_hb & loc
let l_hbl = l_hb & loc
let hbl = g_hbl | l_hbl


{%(*
\paragraph{Visible side effects.}
We define $\var{vse}(\var{hbl})$ as the set of pairs of events $(A,B)$ for which the write $A$ is visible to the read $B$ of the same location, which means that $B$ happens-after $A$ and there is no intervening write to the same location. There are global and local versions of this relation.
\myquote{p.~46}{
A \emph{visible side effect} $A$ on a global object $M$ with respect to a value computation $B$ of $M$ satisfies the conditions:
\begin{itemize}
\item $A$ global-happens-before $B$, and
\item there is no other side effect $X$ to $M$ such that $A$ global-happens-before $X$ and $X$ global-happens-before $B$.
\end{itemize}
We define visible side effects for local objects $M$ similarly.
}
%*)}

let vse(hbl) = [W]; (hbl & ~(hbl; [W]; hbl)); [R]
let g_vse = [global_loc]; vse(g_hbl)
let l_vse = [local_loc]; vse(l_hbl)

{%(*
\myquote{p.~47}{
The visible sequence of side effects on a global atomic object $M$, with respect to a value computation $B$ of $M$, is a maximal contiguous sub-sequence of side effects in the modification order of $M$, where the first side effect is visible with respect to $B$, and for every side effect, it is not the case that $B$ global-happens-before it.
}
The relation \var{vsse} contains pairs of writes $(C,A)$ to a location $M$ for which (1) $A$ comes after $C$ in $M$'s modification order and (2) if $C$ is visible to a read $B$ then $B$ does not happen before $A$.
%*)}

let vsse(hbl) = (co & ~(vse(hbl) ; hbl))*

{%(*
\myquote{p.~47}{
The value of $M$, as determined by evaluation $B$, shall be the value stored by some operation in the visible sequence of $M$ with respect to $B$.
}
Essentially: a load can only read from a store that is in its visible sequence of side-effects. \fixme{John: I'm not sure that it quite makes sense to talk of \emph{the} visible sequence of $M$. Doesn't it depend on which write the sequence starts?}
%*)}

let g_rf = rf; g_vse^-1; ~(vsse(g_hbl))
irreflexive g_rf as g_rf_consistent

{%(*
\myquote{p.~46}{
[...] the visible sequence of side effects for a local atomic object is defined similarly by using the local-happens-before relation.
}
%*)}

let l_rf = rf; l_vse^-1; ~(vsse(l_hbl))
irreflexive l_rf as l_rf_consistent

{%(*
\paragraph{Coherence}
There are four types of coherence-violating cycle, and these are all forbidden in OpenCL. These are write-write, read-read, read-write and write-read. Coherence is required on both the global and the local memory regions.

\myquote{p.~47}{
If an operation $A$ that modifies an atomic object $M$ global-happens-before an operation $B$ that modifies $M$, then $A$ shall be earlier than $B$ in the modification order of $M$. This requirement is known as \emph{write-write coherence}.
}
%*)}

let coww(hbl) = co; hbl

{%(*
\myquote{p.~47}{
If a value computation $A$ of an atomic object $M$ global-happens-before a value computation $B$ of $M$, and $A$ takes its value from a side effect $X$ on $M$, then the value computed by $B$ shall either equal the value stored by $X$, or be the value stored by a side effect $Y$ on $M$, where $Y$ follows $X$ in the modification order of $M$. This requirement is known as \emph{read-read coherence}.
}
%*)}

let corr(hbl) = fr; rf; hbl

{%(*
\myquote{p.~47}{
If a value computation $A$ of an atomic object $M$ global-happens-before an operation $B$ on $M$, then $A$ shall take its value from a side effect $X$ on $M$, where $X$ precedes $B$ in the modification order of $M$. This requirement is known as \emph{read-write coherence}.
}
%*)}

let corw(hbl) = co; rf; hbl

{%(*
\myquote{p.~47}{
If a side effect $X$ on an atomic object $M$ global-happens-before a value computation $B$ of $M$, then the evaluation $B$ shall take its value from $X$ or from a side effect $Y$ that follows $X$ in the modification order of $M$. This requirement is known as \emph{write-read coherence}.
}
%*)}

let cowr(hbl) = fr; hbl

let coherence(r) = corr(r) | cowr(r) | corw(r) | coww(r)
irreflexive coherence(g_hbl) as global_coherence
irreflexive coherence(l_hbl) as local_coherence

{%(*
\paragraph{Read-modify-write atomicity}~
\myquote{p.~49}{
Atomic read-modify-write operations should always read the last value (in the modification order) stored before the write associated with the read-modify-write operation.
}
\fixme{John: I haven't understood the following line yet.}
%*)}

let rmwv = rf;[rmw] | (co;fr) | (co;rf)
irreflexive rmwv as rmw_atomicity

{%(*
\paragraph{Sequential consistency}
We define \var{sc_co} as the per-location modification order (\var{co}) restricted to SC accesses. It contains the pair of events $(a,b)$ only if both are annotated with \code{memory_order_seq_cst}. The event $a$ is either an SC write to $x$ or an SC fence that precedes a write to $x$ in program order. The event $b$ is either a SC write to $x$ or an SC fence that follows a write to $x$ in program order. \fixme{Mark: There should be two models, with this optional. Also, there's no restriction to local or global here. Is that right?}
%*)}

let sc_co = 
  [mo_sc]; ([F]; po)?; co; (po; [F])?; [mo_sc]

{%(*
We define \var{sc_fr} as the from-read relation (\var{fr}) restricted to SC events. \fixme{John: We should say more about this. Also, I added in the disjunct \code{[mo_sc]; fr; [mo_sc]} which wasn't previously allowed. Hopefully that's ok.}
%*)}

let sc_fr1 = [mo_sc]; rf^-1; hbl; [W & mo_sc]
let sc_fr2 = [mo_sc]; rf^-1; [mo_sc]; co; [mo_sc]
let sc_fr3 = [mo_sc]; ([F]; po)?; fr; (po; [F])?; [mo_sc]
let sc_fr = sc_fr1 | sc_fr2 | (neq & sc_fr3)

{%(*
We define \var{sc_ghb} and \var{sc_lhb} as the global and local happens-before relations restricted to SC events.
%*)}

let sc_ghb = [mo_sc]; g_hb; [mo_sc]
let sc_lhb = [mo_sc]; l_hb; [mo_sc]

{%(*
The various sc relations must not form cycles.
%*)}

let scp = sc_ghb | sc_lhb | sc_co | sc_fr
acyclic scp as sc_consistent

{%(*
\paragraph{Data races}

Two events \emph{conflict} if at least one is a write and they access the same location.
\myquote{p.~45}{
Two expression evaluations conflict if one of them modifies a memory location and the other one reads or modifies the same memory location. 
}
%*)}

let conflict = ((W * _) | (_ * W)) & loc

{%(*
There is a \emph{data race} between a pair of events if they conflict, they are unrelated by happens-before, and their scopes are not inclusive.
\myquote{p.~46}{
The execution of a program contains a data race if it contains two conflicting actions $A$ and $B$ in different units of execution, and
\begin{enumerate}
\item at least one of $A$ or $B$ is not atomic, or $A$ and $B$ do not have inclusive memory scope, and 
\item the actions are global actions unordered by the global-happens-before relation or are local actions unordered by the local-happens-before relation.
\end{enumerate}
Any such data race results in undefined behavior.
}
%*)}

let dr = conflict & ~symm(hb) & ~incl
undefined_unless empty dr as data_race 

{%(*
\paragraph{Unsequenced races}
There is an \emph{unsequenced race} between a pair of events if they are different events, they belong to the same work-item, they conflict, and they are unrelated by program-order.
%*)}

let ur = neq & wi & conflict & ~symm(po)
undefined_unless empty ur as unsequenced_race 
